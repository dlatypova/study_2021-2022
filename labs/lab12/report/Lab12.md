---
## Front matter
title: "Лабораторная работа №12"
subtitle: "Программирование в командном процессоре ОС UNIX. Расширенное программирование"
author: "Латыпова Диана. НФИбд-02-21"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить основы программирования в оболочке ОС UNIX. Научиться писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

# Задание

1. Написать командный файл, реализующий упрощённый механизм семафоров. Командный файл должен в течение некоторого времени t1 дожидаться освобождения ресурса, выдавая об этом сообщение, а дождавшись его освобождения, использовать его в течение некоторого времени t2<>t1, также выдавая информацию о том, что ресурс используется соответствующим командным файлом (процессом). Запустить
командный файл в одном виртуальном терминале в фоновом режиме, перенаправив его вывод в другой (> /dev/tty#, где # — номер терминала куда перенаправляется вывод), в котором также запущен этот файл, но не фоновом, а в привилегированном режиме. Доработать программу так, чтобы имелась возможность взаимодействия трёх и более процессов.

2. Реализовать команду man с помощью командного файла. Изучите содержимое каталога /usr/share/man/man1. В нем находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд. Каждый архив можно открыть командой less сразу же просмотрев содержимое справки. Командный файл должен получать в виде аргумента командной строки название команды и в виде результата выдавать справку об этой команде или сообщение об отсутствии справки, если соответствующего файла нет в каталоге man1.

3. Используя встроенную переменную $RANDOM, напишите командный файл, генерирующий случайную последовательность букв латинского алфавита. Учтите, что $RANDOM выдаёт псевдослучайные числа в диапазоне от 0 до 32767.

# Выполнение лабораторной работы

1. Открыла терминал, открыла редактор emacs 12_1:

**emacs 12_1**

Написала скрипт к 1 заданию(рис. [-@fig:001]):

lockfile="./locking.file"

    exec {fn}>$lockfile

    if test -f "$lockfile"
    then
	while [ 1!=0 ]
	do
		if flock -n ${fn}
		then
			echo "File was locked"
			sleep 2
			echo "Unlocking"
			flock -u ${fn}
		else
			echo "File already locked"
			sleep 2
		fi
	done
fi

![Скрипт 1 задания](image/1%20script.png){ #fig:001 width=70% }

Сначала предоставила права на выполнение файла 12_1. И запустила файл(рис. [-@fig:002]):

1 **chmod +x 12_1**

2 **./12_1**

![Результат 1 скрипта](image/1%20result.png){ #fig:002 width=70% }

2. Далее через терминал снова открыл редактор emacs, только уже открыла файл 12_2. Написала там скрипт 2 задания(рис. [-@fig:003]):

command=""

    while getopts :m: opt

do

	  case $opt in
	  m)command="$OPTARG";;
	  esac
done

    if test -f "/usr/share/man/man1/$command.1.gz"
    then less /usr/share/man/man1/$command.1.gz
fi

![Скрипт 2 задания](image/2%20script.png){ #fig:003 width=70% }

Снова предоставила права на выполнение файла 12_2. И запустила файл(рис. [-@fig:004])(рис. [-@fig:005]):

1 **chmod +x 12_2**

2 **./12_2 -m ls**

![Результат 2 скрипта(1)](image/2%20result1.png){ #fig:004 width=70% }

![Результат 2 скрипта(2)](image/2%20result2.png){ #fig:005 width=70% }

3. И наконец открыла в emacs файл 12_3, написала там скрипт 3 задания(рис. [-@fig:006]):

       echo "random password: "

       cat /dev/urandom | tr -dc "a-zA-Z0-9" | fold -w 13 | head -n 1

![Скрипт 3 задания](image/3%20script.png){ #fig:006 width=70% }

Предоставила права на выполнение файла 12_. И запустила файл(рис. [-@fig:007]):

1 **chmod +x 12_3**

2 **./12_3**

![Результат 3 скрипта](image/3%20result.png){ #fig:007 width=70% }

# Контрольные вопросы

1. Найдите синтаксическую ошибку в следующей строке:

        while [$1 != "exit"]

$1. Так же между скобками должны быть пробелы. В противном случае скобки и рядом стоящие символы будут восприниматься как одно целое

2. Как объединить (конкатенация) несколько строк в одну?

       cat file.txt | xargs | sed -e 's/. /.\n/g'

3. Найдите информацию об утилите seq. Какими иными способами можно реализовать её функционал при программировании на bash?

Команда seq выводит последовательность целых или действительных чисел, подходящую для передачи в другие программы.

Команда seq может пригодиться в различных других командах и циклах для генерации последовательности чисел.

Общий синтаксис команды «seq»:

    # seq [options] specification
или

Реализовать ее функционал можно командой 

    for n in {1..5} do <КОМАНДА> done

4. Какой результат даст вычисление выражения $ ((10/3))?

3

5. Укажите кратко основные отличия командной оболочки zsh от bash.

Первое, на что мы взглянем (и это один из наиболее значительных аспектов, на мой взгляд) – это популярность оболочки. Хотя у Z Shell имеется ряд пользователей в среде разработчиков, обычно безопаснее писать свои скрипты для Bash, поскольку гораздо больше людей способны запустить эти скрипты.

Важность всего этого заключается в адаптации скриптов для общедоступных репозиториев, а также в возможности написать грамотную документацию. Благодаря своему большому сообществу для Bash есть несколько крупных ресурсов, которые смогут помочь вам разобраться, как её использовать.

Так что, если вы собираетесь писать скрипт, который легко будет запускать множество разработчиков, то я рекомендую вам Bash. Хотя это не должно помешать вам использовать Z Shell там, где она более применима для ваших целей. Найти верное решение задачи гораздо важнее, чем взять то, что популярно, так что имейте это в виду.

Хотя Bash куда более распространён, это не означает, что у Z Shell нет полезных возможностей. Её часто хвалят за интерактивную работу, поскольку она лучше настраивается, чем Bash. Например, командная строка более гибкая. Можно отобразить команду слева, а другую справа, как в разделённом экране vim. Автодополнение также быстрее и более изменяемое, чем в Bash.

6. Проверьте, верен ли синтаксис данной конструкции

       for ((a=1; a <= LIMIT; a++))

верен

7. Сравните язык bash с какими-либо языками программирования. Какие преимущества у bash по сравнению с ними? Какие недостатки?

Bash позволяет очень легко работать с файловой системой без лишних конструкций (в отличи от обычного языка программирования). Но относительно обычных языков программирования bash очень сжат. Тот же Си имеет гораздо более широкие возможности для разработчика.

# Выводы

Я изучила основы программирования в оболочке ОС UNIX, а также научилась писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.


